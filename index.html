<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PortionPerfect </title>
  
  <style>
  :root{
    --bg:#FBFAF7;
    --card:#FFFFFF;
    --text:#151515;
    --muted:#6B6B6B;
    --border:#E9E4DC;
    --shadow: 0 18px 45px rgba(20,20,20,.08);
    --radius: 18px;
    --accent:#1A1A1A;
    --focus: rgba(26,26,26,.10);
  }

  *{ box-sizing:border-box; }

  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: radial-gradient(1200px 600px at 20% -10%, #FFFFFF 0%, var(--bg) 55%);
    color: var(--text);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .wrap{
    max-width: 1040px;
    margin: 0 auto;
    padding: 18px;
  }

  /* Top bar */
  .topbar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    padding: 10px 2px 16px;
  }
  .brand{
    display:flex;
    flex-direction:column;
    gap:4px;
  }
  .brand h1{
    font-size: 22px;
    margin:0;
    letter-spacing:.2px;
  }
  .brand p{
    margin:0;
    color: var(--muted);
    font-size: 13px;
  }
  .badge{
    font-size: 12px;
    color: var(--muted);
    border:1px solid var(--border);
    background:#fff;
    padding: 6px 10px;
    border-radius: 999px;
    white-space:nowrap;
  }

  /* Control panel */
  .panel{
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
    display:flex;
    flex-wrap:wrap;
    gap: 12px;
    align-items:center;
  }

  .field{
    display:flex;
    flex-direction:column;
    gap:6px;
    min-width: 150px;
  }
  label{
    font-size: 12px;
    color: var(--muted);
  }
  input[type="number"]{
    width: 160px;
    padding: 12px 12px;
    border-radius: 14px;
    border:1px solid var(--border);
    font-size: 14px;
    outline:none;
    background:#fff;
  }
  input[type="number"]:focus{
    box-shadow: 0 0 0 4px var(--focus);
    border-color: #D8D1C7;
  }

  /* Toggle chips */
  .chips{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    flex: 1 1 auto;
    min-width: 260px;
  }
  .chip{
    display:inline-flex;
    align-items:center;
    gap:8px;
    border: 1px solid var(--border);
    background:#fff;
    padding: 9px 12px;
    border-radius: 999px;
    font-size: 13px;
    color: var(--text);
    user-select:none;
  }
  .chip input{
    width: 16px;
    height: 16px;
    accent-color: var(--accent);
  }

  /* Buttons */
  .actions{
    display:flex;
    gap:10px;
    margin-left:auto;
  }
  button{
    padding: 11px 16px;
    border-radius: 14px;
    border: 1px solid transparent;
    background: var(--accent);
    color: #fff;
    font-weight: 650;
    letter-spacing: .2px;
    cursor:pointer;
    transition: transform .15s ease, opacity .15s ease, background .15s ease;
  }
  button:hover{ opacity:.92; transform: translateY(-1px); }
  button:active{ transform: translateY(0); }
  button.secondary{
    background:#fff;
    color: var(--text);
    border-color: var(--border);
  }
  button.secondary:hover{ background:#FEFDFB; }

  /* Main layout */
  .grid{
    display:grid;
    grid-template-columns: 1fr;
    gap: 14px;
    margin-top: 14px;
  }
  @media (min-width: 920px){
    .grid{ grid-template-columns: 1fr 1fr; }
  }

  .card{
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 14px;
  }

  .cardhead{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    margin-bottom: 10px;
  }
  .cardtitle{
    font-size: 13px;
    color: var(--muted);
    display:flex;
    align-items:center;
    gap:8px;
  }
  .pill{
    border:1px solid var(--border);
    background:#fff;
    color: var(--muted);
    font-size: 12px;
    padding: 3px 10px;
    border-radius: 999px;
  }

  textarea{
    width: 100%;
    min-height: 380px;
    resize: vertical;
    padding: 14px;
    border-radius: 16px;
    border:1px solid var(--border);
    font-size: 14px;
    line-height: 1.55;
    outline:none;
    background:#FFFEFC;
  }
  textarea:focus{
    box-shadow: 0 0 0 4px var(--focus);
    border-color: #D8D1C7;
  }

  .out{
    white-space: pre-wrap;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    font-size: 14px;
    line-height: 1.65;
    background: #FFFEFC;
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 14px;
    min-height: 380px;
  }

  .hint{
    margin-top: 10px;
    color: var(--muted);
    font-size: 12px;
  }
</style>
</head>
<body>
<div class="topbar">
  <div class="brand">
    <h1>PortionPerfect</h1>
    <p>Smart recipe scaling. No guesswork.</p>
  </div>
  <div class="badge">Free • No login • Mobile-friendly</div>
</div>

<div class="panel">
  <div class="field">
    <label>Original servings</label>
    <input id="origServ" type="number" value="10" min="1" step="1" />
  </div>

  <div class="field">
    <label>Target servings</label>
    <input id="targetServ" type="number" value="5" min="1" step="1" />
  </div>

  <div class="chips">
    <label class="chip"><input id="doConvert" type="checkbox" checked /> Convert units</label>
    <label class="chip"><input id="doDensity" type="checkbox" checked /> Density (cup→grams)</label>
    <label class="chip"><input id="doRound" type="checkbox" checked /> Kitchen rounding</label>
  </div>

  <div class="actions">
    <button id="scaleBtn">Scale</button>
    <button id="copyBtn" class="secondary">Copy output</button>
  </div>
</div>
    <div class="grid">
      <div class="card">
        <div class="small">
          <span class="pill">Tip</span> One ingredient per line is best. Examples: “1 1/2 cup atta”, “2–3 tsp chilli”, “Salt to taste”, “1 katori curd”.
        </div>
        <textarea id="inText">
1 1/2 cup atta (whole wheat flour)
3/4 cup water
2–3 tsp red chilli powder
1 tbsp ghee
1 katori curd
Salt to taste
Oil for frying
        </textarea>
      </div>

      <div class="card">
        <div class="small"><span class="pill">Output</span>Scaled ingredients</div>
        <div id="out" class="out"></div>
        <div class="hint">Note: “to taste / as needed / for frying” stays unchanged. Density conversion uses a small built-in table you can expand.</div>
      </div>
    </div>
  </div>

<script>
/** =========================
 *  1) Customize these tables
 *  ========================= */

// Common unicode fractions mapping
const UNICODE_FRACS = {
  "½": "1/2", "⅓": "1/3", "⅔": "2/3", "¼": "1/4", "¾": "3/4",
  "⅕": "1/5", "⅖": "2/5", "⅗": "3/5", "⅘": "4/5",
  "⅙": "1/6", "⅚": "5/6",
  "⅛": "1/8", "⅜": "3/8", "⅝": "5/8", "⅞": "7/8",
};

// Unit aliases → canonical unit
const UNIT_ALIASES = new Map([
  ["teaspoon","tsp"],["teaspoons","tsp"],["tsp","tsp"],["t","tsp"],
  ["tablespoon","tbsp"],["tablespoons","tbsp"],["tbsp","tbsp"],["tbl","tbsp"],["tb","tbsp"],
  ["cup","cup"],["cups","cup"],
  ["ml","ml"],["milliliter","ml"],["milliliters","ml"],["millilitre","ml"],["millilitres","ml"],
  ["l","l"],["liter","l"],["liters","l"],["litre","l"],["litres","l"],
  ["g","g"],["gram","g"],["grams","g"],
  ["kg","kg"],["kilogram","kg"],["kilograms","kg"],
  ["oz","oz"],["ounce","oz"],["ounces","oz"],
  ["lb","lb"],["pound","lb"],["pounds","lb"],

  // Indian/common cooking units
  ["katori","katori"],
  ["glass","glass"],
  ["pinch","pinch"],["pinches","pinch"],
  ["handful","handful"],["handfuls","handful"],
  ["clove","clove"],["cloves","clove"],
  ["piece","piece"],["pieces","piece"],
]);

// Approx “volume” conversions (very rough for katori/glass/handful/pinch — tweak if you want)
const VOLUME_TO_ML = {
  tsp: 5,
  tbsp: 15,
  cup: 240,
  katori: 150,  // often 150–200ml; pick your standard
  glass: 250,
  pinch: 0.3,
  handful: 40,  // depends hugely — treat as heuristic
};

// Density table for cup→grams (approx). You can expand this list.
// Keys are ingredient "match tokens" found in the ingredient text.
const CUP_TO_GRAMS = [
  { match: /atta|wheat\s*flour|whole\s*wheat\s*flour/i, gPerCupMin: 120, gPerCupMax: 150 },
  { match: /basmati|rice(?!\s*flour)/i, gPerCupMin: 175, gPerCupMax: 205 },
  { match: /poha/i, gPerCupMin: 140, gPerCupMax: 140 },
];

// Phrases we do NOT scale (kept as-is)
const NON_SCALING_PHRASES = [
  /to\s*taste/i,
  /as\s*needed/i,
  /as\s*required/i,
  /for\s*frying/i,
  /for\s*greasing/i,
  /as\s*per\s*taste/i,
  /optional/i,
  /pinch\s*of\s*salt/i, // example: keep if you prefer (remove if you want it scaled)
];

/** =========================
 *  2) Parsing + Scaling logic
 *  ========================= */

function normalizeLine(line) {
  let s = line.trim();
  // Replace unicode fractions with ascii like "1/2"
  for (const [u, rep] of Object.entries(UNICODE_FRACS)) {
    s = s.replaceAll(u, rep);
  }
  // Normalize en-dash/em-dash to hyphen for ranges
  s = s.replace(/[–—]/g, "-");
  // Collapse multiple spaces
  s = s.replace(/\s+/g, " ");
  return s;
}

function hasNonScalingPhrase(line) {
  return NON_SCALING_PHRASES.some(rx => rx.test(line));
}

function parseNumberToken(token) {
  // Handles "1", "3/4", "1 1/2" (this function expects a single token; mixed handled elsewhere)
  if (/^\d+(\.\d+)?$/.test(token)) return parseFloat(token);
  if (/^\d+\/\d+$/.test(token)) {
    const [a,b] = token.split("/").map(Number);
    if (b === 0) return NaN;
    return a / b;
  }
  return NaN;
}

function parseQuantityStart(line) {
  // Attempt to parse quantity at the very start of the line:
  // - "1 1/2"
  // - "3/4"
  // - "2-3"
  // - "2 - 3"
  // - "1.5"
  // Returns { qtyType: "single"|"range"|null, a, b, rest }
  const s = line.trim();

  // Range like "2-3" or "2 - 3" or "1 1/2-2"
  // We'll capture up to first space after the quantity block.
  // Strategy: pull first "chunk" that looks like qty, possibly containing spaces.
  // We'll scan tokens until it no longer looks numeric/fraction/range separator.
  const tokens = s.split(" ");
  if (tokens.length === 0) return { qtyType: null, rest: s };

  // Build a prefix of tokens that could represent qty
  // allow: digits, fractions, decimals, hyphen
  let qtyTokens = [];
  for (let i=0; i<Math.min(tokens.length, 3); i++) { // usually qty fits within first 3 tokens
    const t = tokens[i];
    if (/^\d+(\.\d+)?$/.test(t) || /^\d+\/\d+$/.test(t) || t === "-" || /^\d+(\.\d+)?-\d+(\.\d+)?$/.test(t) || /^\d+\/\d+-\d+\/\d+$/.test(t) ) {
      qtyTokens.push(t);
    } else {
      // mixed number like "1" "1/2"
      if (i===1 && /^\d+$/.test(tokens[0]) && /^\d+\/\d+$/.test(tokens[1])) qtyTokens.push(t);
      else break;
    }
  }
  if (qtyTokens.length === 0) return { qtyType: null, rest: s };

  // Join qtyTokens; handle spaced range "2 - 3"
  let qtyStr = qtyTokens.join(" ");
  // If starts with something like "2 - 3", normalize to "2-3"
  qtyStr = qtyStr.replace(/\s*-\s*/g, "-");

  // Mixed number "1 1/2" not range
  if (/^\d+\s+\d+\/\d+$/.test(qtyTokens.join(" "))) {
    const [whole, frac] = qtyTokens.join(" ").split(" ");
    const val = parseInt(whole,10) + parseNumberToken(frac);
    const rest = s.slice((whole.length + 1 + frac.length)).trim();
    return { qtyType: "single", a: val, rest };
  }

  // Simple single token range like "2-3"
  if (/^[\d\/\.]+-[\d\/\.]+$/.test(qtyStr)) {
    const [left, right] = qtyStr.split("-");
    const a = parseNumberToken(left);
    const b = parseNumberToken(right);
    if (Number.isFinite(a) && Number.isFinite(b)) {
      const rest = s.slice(qtyTokens.join(" ").length).trim();
      return { qtyType: "range", a, b, rest };
    }
  }

  // Single number or single fraction
  const singleToken = qtyTokens[0];
  let val = parseNumberToken(singleToken);
  if (Number.isFinite(val)) {
    const rest = s.slice(singleToken.length).trim();
    return { qtyType: "single", a: val, rest };
  }

  return { qtyType: null, rest: s };
}

function parseUnit(rest) {
  // Unit is usually the first word after qty; sometimes like "(14-oz)" etc.
  // We'll grab the first token that matches UNIT_ALIASES after stripping punctuation.
  const rawTokens = rest.split(" ");
  if (rawTokens.length === 0) return { unit: null, afterUnit: rest };

  // Skip bracket-only tokens like "(14-oz)" by treating as part of description, not unit.
  // But if token contains known unit exactly (like "oz"), we can catch it.
  for (let i=0; i<Math.min(rawTokens.length, 3); i++) {
    const clean = rawTokens[i].toLowerCase().replace(/^[\(\[\{"]+|[\)\]\}":,\.]+$/g, "");
    if (UNIT_ALIASES.has(clean)) {
      const unit = UNIT_ALIASES.get(clean);
      const afterUnit = rawTokens.slice(i+1).join(" ").trim();
      return { unit, afterUnit };
    }
  }
  return { unit: null, afterUnit: rest };
}

function scaleValue(val, factor) {
  return val * factor;
}

function kitchenRound(val) {
  // Friendly rounding:
  // < 1 : round to nearest 0.25
  // 1–10: round to nearest 0.5
  // >10 : round to nearest 1
  if (!Number.isFinite(val)) return val;
  let step = 1;
  if (val < 1) step = 0.25;
  else if (val <= 10) step = 0.5;
  else step = 1;
  return Math.round(val / step) * step;
}

function formatNumber(val) {
  // show integers clean; else up to 2 decimals but trim trailing zeros
  if (!Number.isFinite(val)) return "";
  const isInt = Math.abs(val - Math.round(val)) < 1e-9;
  if (isInt) return String(Math.round(val));
  return String(val.toFixed(2)).replace(/\.?0+$/,"");
}

function maybeConvertUnits(qty, unit, ingredientText, doConvert, doDensity) {
  // Returns { qtyStr, unitStr, extraStr }
  if (!doConvert || !unit) return { qtyStr: formatNumber(qty), unitStr: unit, extraStr: "" };

  // Convert between tsp/tbsp/cup/ml/l where possible
  if (VOLUME_TO_ML[unit]) {
    const ml = qty * VOLUME_TO_ML[unit];

    // Prefer ml for small/medium volumes, l for large
    if (ml >= 1000) {
      const l = ml / 1000;
      return { qtyStr: formatNumber(l), unitStr: "l", extraStr: ` (~${formatNumber(ml)} ml)` };
    }
    // If tsp/tbsp/cup stay, but also show ml
    return { qtyStr: formatNumber(qty), unitStr: unit, extraStr: ` (~${formatNumber(ml)} ml)` };
  }

  // If unit is ml, also show tbsp/tsp approx
  if (unit === "ml") {
    const tbsp = qty / VOLUME_TO_ML.tbsp;
    const tsp = qty / VOLUME_TO_ML.tsp;
    let extra = "";
    if (tbsp >= 1) extra = ` (~${formatNumber(tbsp)} tbsp)`;
    else extra = ` (~${formatNumber(tsp)} tsp)`;
    return { qtyStr: formatNumber(qty), unitStr: unit, extraStr: extra };
  }

  // If unit is cup and density conversion enabled, try grams
  if (doDensity && unit === "cup") {
  const match = CUP_TO_GRAMS.find(x => x.match.test(ingredientText));
  if (match) {
    const gMin = qty * match.gPerCupMin;
    const gMax = qty * match.gPerCupMax;

    const gramsStr =
      Math.abs(gMin - gMax) < 1e-9
        ? `${formatNumber(gMin)} g`
        : `${formatNumber(gMin)}–${formatNumber(gMax)} g`;

    return { qtyStr: formatNumber(qty), unitStr: unit, extraStr: ` (~${gramsStr})` };
  }
}
  return { qtyStr: formatNumber(qty), unitStr: unit, extraStr: "" };
}

function scaleLine(line, factor, opts) {
  const raw = line;
  const s = normalizeLine(line);
  if (!s) return "";

  // Keep as-is if clearly non-scalable
  if (hasNonScalingPhrase(s)) return raw;

  const q = parseQuantityStart(s);
  if (!q.qtyType) return raw; // no quantity detected

  const { unit, afterUnit } = parseUnit(q.rest);
  const ingredientText = (unit ? afterUnit : q.rest);

  const doRound = opts.doRound;

  if (q.qtyType === "single") {
    let newQty = scaleValue(q.a, factor);
    if (doRound) newQty = kitchenRound(newQty);
    const conv = maybeConvertUnits(newQty, unit, ingredientText, opts.doConvert, opts.doDensity);
    const unitPart = unit ? ` ${conv.unitStr}` : "";
    const tail = unit ? afterUnit : q.rest;
    return `${conv.qtyStr}${unitPart} ${tail}`.trim() + (conv.extraStr || "");
  }

  if (q.qtyType === "range") {
    let a = scaleValue(q.a, factor);
    let b = scaleValue(q.b, factor);
    if (doRound) { a = kitchenRound(a); b = kitchenRound(b); }
    const aStr = formatNumber(a), bStr = formatNumber(b);
    const tail = unit ? afterUnit : q.rest;
    // For ranges, show ml approx if possible (using midpoint)
    let extra = "";
    if (opts.doConvert && unit && VOLUME_TO_ML[unit]) {
      const mid = (a + b) / 2;
      const ml = mid * VOLUME_TO_ML[unit];
      extra = ml ? ` (~${formatNumber(ml)} ml mid)` : "";
    }
    const unitPart = unit ? ` ${unit}` : "";
    return `${aStr}–${bStr}${unitPart} ${tail}`.trim() + extra;
  }

  return raw;
}

function scaleAll() {
  const orig = Number(document.getElementById("origServ").value);
  const target = Number(document.getElementById("targetServ").value);
  const factor = target / orig;

  const opts = {
    doConvert: document.getElementById("doConvert").checked,
    doDensity: document.getElementById("doDensity").checked,
    doRound: document.getElementById("doRound").checked,
  };

  const input = document.getElementById("inText").value.split("\n");
  const outLines = input.map(line => scaleLine(line, factor, opts)).filter(x => x !== "");
  document.getElementById("out").textContent = outLines.join("\n");
}

document.getElementById("scaleBtn").addEventListener("click", scaleAll);
document.getElementById("copyBtn").addEventListener("click", async () => {
  const text = document.getElementById("out").textContent || "";
  try {
    await navigator.clipboard.writeText(text);
    alert("Copied!");
  } catch {
    alert("Copy failed (browser permission). You can select + copy manually.");
  }
});

// Initial render
scaleAll();
</script>
</body>
</html>





